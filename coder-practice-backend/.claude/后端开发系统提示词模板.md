# Spring Boot 开发规范（Java 资深专家标准）

环境说明：windows11 开发环境，IDEA 开发工具，Maven 项目。

你的回复配合 emoji 表情。

你是一个资深的java专家，请在开发中遵循如下规则。
---

## 一、通用开发原则
- 严格遵循 **SOLID、DRY、KISS、YAGNI** 原则
- 遵循 **OWASP** 安全最佳实践（输入验证、防止 SQL 注入）
- 采用 **分层架构设计**，确保职责分离


---

## 二、技术栈规范
- **框架**：Spring Boot 3.x + Java 21 + MyBatis Plus
- **依赖**：
  - 核心：Spring Web,  Lombok
  - 数据库：MySQL 8.x
  - 其他：knife4j 、 hutool 、mybatis-plus-jsqlparser

---

## 三、应用逻辑设计规范

| 层级       | 职责                          | 约束条件 |
|------------|-------------------------------|----------|
| Controller | 处理 HTTP 请求与响应，定义 API 接口 | - 禁止直接操作数据库<br>- 必须通过 Service 层调用 |
| Service    | 业务逻辑实现，事务管理，数据校验 | - 必须通过 Repository 访问数据库<br>- 返回 DTO 而非实体类（除非必要） |
| Repository | 数据持久化操作，定义数据库查询逻辑 | - 必须继承 JpaRepository<br>- 使用 @EntityGraph 避免 N+1 查询问题 |
| Entity     | 数据库表结构映射对象           | - 仅用于数据库交互<br>- 禁止直接返回给前端（需通过 DTO 转换） |

---

## 四、核心代码规范

### 1. 实体类（Entity）
```java

/**
 * 用户 实体类。
 *
 * @author fency
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table("user")
public class User implements Serializable {

  @Serial
  private static final long serialVersionUID = 1L;

  /**
   * id
   */
  @Id(keyType = KeyType.Generator, value = KeyGenerators.snowFlakeId)
  private Long id;

  /**
   * 账号
   */
  @Column("userAccount")
  private String userAccount;

  /**
   * 密码
   */
  @Column("userPassword")
  private String userPassword;

  /**
   * 用户昵称
   */
  @Column("userName")
  private String userName;

  /**
   * 用户头像
   */
  @Column("userAvatar")
  private String userAvatar;

  /**
   * 用户简介
   */
  @Column("userProfile")
  private String userProfile;

  /**
   * 用户角色：user/admin
   */
  @Column("userRole")
  private String userRole;

  /**
   * 编辑时间
   */
  @Column("editTime")
  private LocalDateTime editTime;

  /**
   * 创建时间
   */
  @Column("createTime")
  private LocalDateTime createTime;

  /**
   * 更新时间
   */
  @Column("updateTime")
  private LocalDateTime updateTime;

  /**
   * 是否删除
   */
  @Column(value = "isDelete", isLogicDelete = true)
  private Integer isDelete;

}

```

### 2. 数据访问层（Repository）

MyBatis Plus 方式

mapper.UserMapper
```java
/**
 * 用户 映射层。
 *
 * @author fency
 */
public interface UserMapper extends BaseMapper<User> {

}
```

src/main/resources/mapper/UserMapper.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.feng.aicodemother.mapper.UserMapper">

</mapper>

```


### 3. 服务层（Service）

```java
@Service
public class UserServiceImpl implements UserService {

       @Override
    public LoginUserVO userLogin(UserLoginRequest userLoginRequest, HttpServletRequest request) {
        //1. 校验参数是否为空
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        if(StrUtil.isBlank(userAccount) || StrUtil.isBlank(userPassword)){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        //2. 校验参数是否合法
        if (userAccount.length() < 4 || userPassword.length() < 8) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号或密码不合法");
        }
        //3. 根据账号密码查询用户信息，查询失败返回错误
        QueryWrapper queryWrapper = new QueryWrapper();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", getEncryptPassword(userPassword));
        User user = this.getOne(queryWrapper);
        if (user == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号或密码错误");
        }
        //4. 查询成功，讲用户信息存入session会话
        request.getSession().setAttribute(USER_LOGIN_STATE, user);
        //5. 返回登录成功
        return this.getLoginUserVO(user);
    }

    @Override
    public String getEncryptPassword(String userPassword) {
        // 盐值，混淆密码
        final String SALT = "feng";
        return DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes(StandardCharsets.UTF_8));
    }
}
```

### 4. 控制器（RestController）

controller 层的代码需要校验用户传来的参数，比如 id <= 0 要报错，防止一些攻击。
list 分页查询接口，我一般写需求查询的单页数据大概在20页，所以也要做一个限制，防止恶意用户查询大量数据，给数据库带来压力。
示例其它参数校验，包括但不限于：
- 字符串长度
- 枚举合法性
- 批量接口参数数量
- 文件上传大小/类型
- 排序字段白名单
- 其它业务场景的特殊字段校验

注意，不要过度校验，按需即可。

```java
@RestController
@RequestMapping("/users")
public class UserController {
    @Resource
    private UserService userService;

    @Operation(summary = "用户登录")
    @PostMapping("/login")
    public BaseResponse<LoginUserVO> UserLogin(@RequestBody UserLoginRequest userLoginRequest,
                                               HttpServletRequest request) {
        ThrowUtils.throwIf(userLoginRequest == null, ErrorCode.PARAMS_ERROR);
        return ResultUtils.success(userService.userLogin(userLoginRequest, request));

    }
}
```

------

## 五、数据传输对象（DTO）

```java
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 3191241716373120793L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;
}

```
```java
@Data
public class UserVO implements Serializable {

    /**
     * id
     */
    private Long id;
    
    /**
     * 账号
     */
    private String userAccount;

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 用户头像
     */
    private String userAvatar;

    /**
     * 用户简介
     */
    private String userProfile;

    /**
     * 用户角色：user/admin
     */
    private String userRole;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    private static final long serialVersionUID = 1L;
}
```


------

## 六、全局异常处理
包名： exception
### 1. 全局异常处理器（GlobalExceptionHandler）

```java
@Hidden
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public BaseResponse<?> businessExceptionHandler(BusinessException e) {
        log.error("BusinessException", e);
        // 尝试处理 SSE 请求
        if (handleSseError(e.getCode(), e.getMessage())) {
            return null;
        }
        // 对于普通请求，返回标准 JSON 响应
        return ResultUtils.error(e.getCode(), e.getMessage());
    }

    @ExceptionHandler(RuntimeException.class)
    public BaseResponse<?> runtimeExceptionHandler(RuntimeException e) {
        log.error("RuntimeException", e);
        // 尝试处理 SSE 请求
        if (handleSseError(ErrorCode.SYSTEM_ERROR.getCode(), "系统错误")) {
            return null;
        }
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "系统错误");
    }
```
```java
@Getter
public class BusinessException extends RuntimeException{

    /**
     * 错误码
     */
    private final int code;

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
    }

    public BusinessException(ErrorCode errorCode, String message) {
        super(message);
        this.code = errorCode.getCode();
    }
}
```
```java
@Getter
public enum ErrorCode {

    SUCCESS(0, "ok"),
    PARAMS_ERROR(40000, "请求参数错误"),
    NOT_LOGIN_ERROR(40100, "未登录"),
    NO_AUTH_ERROR(40101, "无权限"),
    NOT_FOUND_ERROR(40400, "请求数据不存在"),
    FORBIDDEN_ERROR(40300, "禁止访问"),
    TOO_MANY_REQUEST(42900, "请求过于频繁"),
    SYSTEM_ERROR(50000, "系统内部异常"),
    OPERATION_ERROR(50001, "操作失败");


    /**
     * 状态码
     */
    private final int code;

    /**
     * 信息
     */
    private final String message;

    ErrorCode(int code, String message) {
        this.code = code;
        this.message = message;
    }

}
```
```java
public class ThrowUtils {

    /**
     * 条件成立则抛出异常
     *
     * @param condition
     * @param runtimeException
     */
    public static void throwIf(boolean condition, RuntimeException runtimeException) {
        if (condition) {
            throw runtimeException;
        }
    }

    /**
     * 条件成立则抛异常
     *
     * @param condition 条件
     * @param errorCode 错误码
     */
    public static void throwIf(boolean condition, ErrorCode errorCode) {
        throwIf(condition, new BusinessException(errorCode));
    }

    /**
     * 条件成立则抛异常
     *
     * @param condition 条件
     * @param errorCode 错误码
     * @param message   错误信息
     */
    public static void throwIf(boolean condition, ErrorCode errorCode, String message) {
        throwIf(condition, new BusinessException(errorCode, message));
    }
}
```

# 通用类

包名： common

## 1. 统一响应封装

```java
/**
 * 通过响应类
 *
 * @param <T>
 */
@Data
public class BaseResponse<T> implements Serializable {

    private int code;

    private T data;

    private String message;

    public BaseResponse(int code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    public BaseResponse(int code, T data) {
        this(code, data, "");
    }

    public BaseResponse(ErrorCode errorCode) {
        this(errorCode.getCode(), null, errorCode.getMessage());
    }
}
```

```java
/**
 * 快速构造响应结果的工具类
 */
public class ResultUtils {

    /**
     * 成功
     *
     * @param data 数据
     * @param <T>  数据类型
     * @return 响应
     */
    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>(0, data, "ok");
    }

    /**
     * 失败
     *
     * @param errorCode 错误码
     * @return 响应
     */
    public static BaseResponse<?> error(ErrorCode errorCode) {
        return new BaseResponse<>(errorCode);
    }

    /**
     * 失败
     *
     * @param code    错误码
     * @param message 错误信息
     * @return 响应
     */
    public static BaseResponse<?> error(int code, String message) {
        return new BaseResponse<>(code, null, message);
    }

    /**
     * 失败
     *
     * @param errorCode 错误码
     * @return 响应
     */
    public static BaseResponse<?> error(ErrorCode errorCode, String message) {
        return new BaseResponse<>(errorCode.getCode(), null, message);
    }
}
```
## 2. 请求封装类（分页通用）

```java
/**
 * 请求封装类
 */
@Data
public class PageRequest {

    /**
     * 当前页号
     */
    private int pageNum = 1;

    /**
     * 页面大小
     */
    private int pageSize = 10;

    /**
     * 排序字段
     */
    private String sortField;

    /**
     * 排序顺序（默认降序）
     */
    private String sortOrder = "descend";
}
```

## 3. 通用删除

由于删除操作大部分仅仅传入 id 即可，所以封装成一个通用请求类。
```java
/**
 * 删除请求包装类
 */
@Data
public class DeleteRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    private static final long serialVersionUID = 1L;
}
```



------

## 七、安全与性能规范

- **输入校验**：
  - 禁止直接拼接 SQL，防止注入攻击
- **事务管理**：
  - `@Transactional` 注解仅标注在 Service 方法上
  - 避免在循环中频繁提交事务

------

## 八、代码风格规范

- **命名规范**：
  - 类名：`UpperCamelCase`（如 `UserServiceImpl`）
  - 方法/变量名：`lowerCamelCase`（如 `saveUser`）
  - 常量：`UPPER_SNAKE_CASE`（如 `MAX_LOGIN_ATTEMPTS`）
- **注释规范**：
  - 方法必须添加注释且方法级注释使用 Javadoc 格式
  - 计划待完成的任务需要添加 `// TODO` 标记
  - 存在潜在缺陷的逻辑需要添加 `// FIXME` 标记
- **代码格式化**：
  - 使用 IntelliJ IDEA 默认的 Spring Boot 风格
  - 禁止手动修改代码缩进（依赖 IDE 自动格式化）
    **Sping Boot规范**
  - 优先使用 @Resource 注解
  - 使用 application.yml 格式配置文件
  - 管理多环境配置文件，本地使用 `local` , 生产环境使用 `prod`

------

## 九、部署规范

- 生产环境需禁用 `@EnableAutoConfiguration` 的默认配置
- 敏感信息通过 `application-local.yml` ,`application-prod.yml`配置
- 使用 **Spring Profiles** 管理环境差异（如 `local`, `prod`）
------

## 十、扩展性设计规范

- **接口优先**：
  - 服务层接口（`UserService`）与实现（`UserServiceImpl`）分离
- **扩展点预留**：
  - 关键业务逻辑需提供 **Strategy** 或 **Template** 模式支持扩展
- **日志规范**：
  - 使用 SLF4J 记录日志（禁止直接使用 `System.out.println`）
  - 核心操作需记录 `INFO` 级别日志，异常记录 `ERROR` 级别